Se todos os outros projetos da tua equipa ou companhia são construídos usando uma ferramenta de construção padronizada como, por exemplo, Ant ou Maven, tu transformas-te na ovelha negra da família quando utilizas a linha de comando Grails para construir a tua aplicação. Felizmente, podes integrar facilmente o sistema de construção Grails nas principais ferramentas de construção em uso hoje em dia (wbem, pelo menos nas que são utilizadas em projetos Java).

h3. Integração Ant

Quando crias uma aplicação Grails com o comando [create-app|commandLine], Grails não cria automaticamente um ficheiro de construção Ant @build.xml@ mas podes gerar um com o comando [integrate-with|commandLine]:

bc.
grails integrate-with --ant

Isto cria um ficheiro @build.xml@ contendo os seguintes alvos:

* @clean@ - Limpa a aplicação Grails
* @compile@ - Compila o código-fonte da aplicação
* @test@ - Corre os teste de unidade
* @run@ - Equivalente a "grails run-app"
* @war@ - Cria o ficheiro WAR
* @deploy@ - Vazio por defeito, mas pode ser utilizado para implementar o "deploy" automático

Cada um destes podem ser corridos por Ant, por exemplo:

{code:java}
ant war
{code}

O ficheiro de construção é configurado para utilizar "Apache Ivy":http://ant.apache.org/ivy/ para a gestão de dependências, o que significa que irá descarregar automaticamente todos os ficheiros JAR Grails e outras dependências quando for necessário. Não tens sequer que instalar Grails localmente para o poder usar ! Isto torna-o particularmente útil para sistemas de integração contínua tais como [CruiseControl|http://cruisecontrol.sourceforge.net/] ou [Jenkins|http://jenkins-ci.org/].

Utiliza a [Ant task|api:grails.ant.GrailsTask] Grails para se ligar ao sistema de construção Grails existente. A tarefa permite-te correr qualquer script Grails que esteja disponível, não apenas aqueles que são utilizados pelo ficheiro de construção gerado. Para utilizar a tarefa deves primeiro declará-la:
{code}
<taskdef name="grailsTask"
         classname="grails.ant.GrailsTask"
         classpathref="grails.classpath"/>
{code}

Isto levanta a questão: o que deve estar no "grails.classpath"? A tarefa propriamente dita está no artefato JAR "grails-bootstrap", por isso precisa, pelo menos, de estar no . Deves também incluir o JAR "groovy-all". Com a tarefa definida, apenas precisas utilizá-la! A tabela seguinte mostra os atributos que estão disponíveis:
{table}
 Atributo | Descrição | Necessário
 home | Localização do diretório de instalação de Grails para usar na construção. | Sim, a não ser que seja especificado o classpath.
 classpathref | Classpath a partir do qual carregar Grails. Deve incluir o artefato "grails-bootstrap" e deve incluir "grails-scripts". | Sim, a menos que @home@ esteja definido ou utilizes um elemento @classpath@ .
 script | O nome do script Grails a correr, ex. "TestApp". | Sim.
 args | Os argumentas a passar para script, ex. "-unit -xml". | Não. Por defeito "".
 environment | O ambiente Grails em que o script deve correr. | Não. Valor por defeito igual ao do script.
 includeRuntimeClasspath | Configuração avançada: Se true adiciona o classpath de tempo de execução da aplicação ao classpath de construção. | Não. Por defeito @true@.
{table}

A tarefa também suporta os seguintes elementos aninhados, todos eles estruturas de caminho Ant padrão:

* @classpath@ - O classpath de construção(utilizado para caregar os scripts Gant e Grails).
* @compileClasspath@ - Classpath utilizado para compilar as classes da aplicação.
* @runtimeClasspath@ - Classpath utilizado para correr a aplicação e empacotar o WAR. Tipicamente inclui tudo em @compileClasspath.
* @testClasspath@ - Classpath utilizado para compilar e correr os testes. Tipicamente inclui tudo em  @runtimeClasspath@.

A forma de popular estes caminhos cabe a cada um. Se utilizas o atributo @home@ e colocas as tuas próprias dependências na directoria @lib@, então nem precisas utilizar nenhum deles. Para um exemplo da sua utilização, espreita o ficheiro de construção Ant gerado para novas aplicações.

h3. Integração Maven

Grails fornece integração com "Maven 2":http://maven.apache.org através de um plugin Maven. O plugin Maven atual é baseado (mas acrescenta) na versãocriada por [Octo|http://forge.octo.com/], que fez um excelente trabalho com o original.

h4. Preparação

Para poder utilizar o novo plugin, tudo o que necessitas é ter Maven 2 instalado e configurado. Isto porque *já não necessitas instalar Grails separadamente para utilizá-lo com Maven!*

{note}
A integração Maven 2 para Grails foi desenhada e testada para Maven 2.0.9 e mais recentes. Não irá funcionar em versões mais antigas.
{note}

{note}
A configuração mvn por defeito NÃO fornece memória suficiente para correr o ambiente Grails. Recomendamos que adiciones a seguinte configuração de variável de ambiente para evitar um mau desempenho:

@export MAVEN_OPTS="-Xmx512m -XX:MaxPermSize=256"@
{note}

h4. Criando um Projeto Maven Grails

Para criar um projeto Grails Mavenizedo basta executar o comando seguinte:

{code}
mvn archetype:generate -DarchetypeGroupId=org.grails \\\
    -DarchetypeArtifactId=grails-maven-archetype \\\
    -DarchetypeVersion=1.3.2 \\\
    -DgroupId=example -DartifactId=my-app
{code}

Escolhe uma qualquer versão de grails, ID de grupo e ID de artefato que desejes para a tua aplicação, mas tudo o resto deve ficar como está escrito. Isto irá criar um novo projeto Maven com um POM e alguns outros ficheiros. Aquilo que não verás é algo que se assemelhe a uma aplicação Grails. Por isso, o próximo passo é criar a estrutura de projeto a que estás habituado.
Mas primeiro, há que configurar o JDK alvo para Java 6, vamos fazê-lo agora. Abre my-app/pom.xml e muda
{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.5</source>
    <target>1.5</target>
  </configuration>
</plugin>
{code}
to
{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.6</source>
    <target>1.6</target>
  </configuration>
</plugin>
{code}

Então estarás pronto para criar a estrutura do projeto:

{code}
cd my-app
mvn initialize
{code}

{note}
se vires uma mensagem semelhante a esta:

{code}
Resolving plugin JAR dependencies ...
:: problems summary ::
:::: WARNINGS
        module not found: org.hibernate#hibernate-core;3.3.1.GA
{code}

necessitas adicionar os plugins manualmente a application.properties:

{code}
plugins.hibernate=2.0.0
plugins.tomcat=2.0.0
{code}

então executa

{code}
mvn compile
{code}

e os plugins hibernate e tomcat serão instalados.
{note}

Now you have a Grails application all ready to go. The plugin integrates into the standard build cycle, so you can use the standard Maven phases to build and package your app:  @mvn clean@ ,  @mvn compile@ ,  @mvn test@ ,  @mvn package@ , @mvn install@ .

You can also use some of the Grails commands that have been wrapped as Maven goals:

* @grails:create-controller@ - Calls the [create-controller|commandLine] command
* @grails:create-domain-class@ - Calls the [create-domain-class|commandLine] command
* @grails:create-integration-test@ - Calls the [create-integration-test|commandLine] command
* @grails:create-pom@ - Creates a new Maven POM for an existing Grails project
* @grails:create-script@ - Calls the [create-script|commandLine] command
* @grails:create-service@ - Calls the [create-service|commandLine] command
* @grails:create-taglib@ - Calls the [create-tag-lib|commandLine] command
* @grails:create-unit-test@ - Calls the [create-unit-test|commandLine] command
* @grails:exec@ - Executes an arbitrary Grails command line script
* @grails:generate-all@ - Calls the [generate-all|commandLine] command
* @grails:generate-controller@  - Calls the [generate-controller|commandLine] command
* @grails:generate-views@ - Calls the [generate-views|commandLine] command
* @grails:install-plugin@ - Calls the [install-plugin|commandLine] command
* @grails:install-templates@ - Calls the [install-templates|commandLine] command
* @grails:list-plugins@ - Calls the [list-plugins|commandLine] command
* @grails:package@ - Calls the [package|commandLine] command
* @grails:run-app@ - Calls the [run-app|commandLine] command
* @grails:uninstall-plugin@ - Calls the [uninstall-plugin|commandLine] command

For a complete, up to date list, run @mvn grails:help@

h4. Mavenizing an existing project

Creating a new project is great way to start, but what if you already have one? You don't want to create a new project and then copy the contents of the old one over. The solution is to create a POM for the existing project using this Maven command (substitute the version number with the grails version of your existing project):
{code}
mvn org.grails:grails-maven-plugin:1.3.2:create-pom -DgroupId=com.mycompany
{code}
When this command has finished, you can immediately start using the standard phases, such as @mvn package@. Note that you have to specify a group ID when creating the POM.

You may also want to set target JDK to Java 6; see above.

h4. Adding Grails commands to phases

The standard POM created for you by Grails already attaches the appropriate core Grails commands to their corresponding build phases, so "compile" goes in the "compile" phase and "war" goes in the "package" phase. That doesn't help though when you want to attach a plugin's command to a particular phase. The classic example is functional tests. How do you make sure that your functional tests (using which ever plugin you have decided on) are run during the "integration-test" phase?

Fear not: all things are possible. In this case, you can associate the command to a phase using an extra "execution" block:
{code:xml}
<plugin>
    <groupId>org.grails</groupId>
    <artifactId>grails-maven-plugin</artifactId>
    <version>1.3.2</version>
    <extensions>true</extensions>
    <executions>
        <execution>
            <goals>
            ...
            </goals>
        </execution>
        <!-- Add the "functional-tests" command to the "integration-test" phase -->
        <execution>
            <id>functional-tests</id>
            <phase>integration-test</phase>
            <goals>
                <goal>exec</goal>
            </goals>
            <configuration>
                <command>functional-tests</command>
            </configuration>
        </execution>
    </executions>
</plugin>
{code}

This also demonstrates the @grails:exec@ goal, which can be used to run any Grails command. Simply pass the name of the command as the @command@ system property, and optionally specify the arguments with the @args@ property:
{code}
mvn grails:exec -Dcommand=create-webtest -Dargs=Book
{code}

h4. Debugging a Grails Maven Project

Maven can be launched in debug mode using the "mvnDebug" command. To launch your Grails application in debug, simply run:

{code}
mvnDebug grails:run-app
{code}

The process will be suspended on startup and listening for a debugger on port 8000.

If you need more control of the debugger, this can be specified using the MAVEN_OPTS environment variable, and launch Maven with the default "mvn" command:

{code}
MAVEN_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"
mvn grails:run-app
{code}

h4. Raising issues

If you come across any problems with the Maven integration, please raise a JIRA issue as a sub-task of [GRAILS-3547|http://jira.codehaus.org/browse/GRAILS-3547].
