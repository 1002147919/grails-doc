Se todos os outros projetos da tua equipa ou companhia são construídos usando uma ferramenta de construção padronizada como, por exemplo, Ant ou Maven, tu transformas-te na ovelha negra da família quando utilizas a linha de comando Grails para construir a tua aplicação. Felizmente, podes integrar facilmente o sistema de construção Grails nas principais ferramentas de construção em uso hoje em dia (wbem, pelo menos nas que são utilizadas em projetos Java).

h3. Integração Ant

Quando crias uma aplicação Grails com o comando [create-app|commandLine], Grails não cria automaticamente um ficheiro de construção Ant @build.xml@ mas podes gerar um com o comando [integrate-with|commandLine]:

bc.
grails integrate-with --ant

Isto cria um ficheiro @build.xml@ contendo os seguintes alvos:

* @clean@ - Limpa a aplicação Grails
* @compile@ - Compila o código-fonte da aplicação
* @test@ - Corre os teste de unidade
* @run@ - Equivalente a "grails run-app"
* @war@ - Cria o ficheiro WAR
* @deploy@ - Vazio por defeito, mas pode ser utilizado para implementar o "deploy" automático

Cada um destes podem ser corridos por Ant, por exemplo:

{code:java}
ant war
{code}

O ficheiro de construção é configurado para utilizar "Apache Ivy":http://ant.apache.org/ivy/ para a gestão de dependências, o que significa que irá descarregar automaticamente todos os ficheiros JAR Grails e outras dependências quando for necessário. Não tens sequer que instalar Grails localmente para o poder usar ! Isto torna-o particularmente útil para sistemas de integração contínua tais como [CruiseControl|http://cruisecontrol.sourceforge.net/] ou [Jenkins|http://jenkins-ci.org/].

Utiliza a [Ant task|api:grails.ant.GrailsTask] Grails para se ligar ao sistema de construção Grails existente. A tarefa permite-te correr qualquer script Grails que esteja disponível, não apenas aqueles que são utilizados pelo ficheiro de construção gerado. Para utilizar a tarefa deves primeiro declará-la:
{code}
<taskdef name="grailsTask"
         classname="grails.ant.GrailsTask"
         classpathref="grails.classpath"/>
{code}

Isto levanta a questão: o que deve estar no "grails.classpath"? A tarefa propriamente dita está no artefato JAR "grails-bootstrap", por isso precisa, pelo menos, de estar no classpath. Deve também incluir o JAR "groovy-all". Com a tarefa definida, apenas precisa utilizá-la! A tabela seguinte mostra os atributos que estão disponíveis:
{table}
 Atributo | Descrição | Necessário
 home | Localização do diretório de instalação de Grails para usar na construção. | Sim, a não ser que seja especificado o classpath.
 classpathref | Classpath a partir do qual carregar Grails. Deve incluir o artefato "grails-bootstrap" e deve incluir "grails-scripts". | Sim, a menos que @home@ esteja definido ou utilizes um elemento @classpath@ .
 script | O nome do script Grails a correr, ex. "TestApp". | Sim.
 args | Os argumentas a passar para script, ex. "-unit -xml". | Não. Por defeito "".
 environment | O ambiente Grails em que o script deve correr. | Não. Valor por defeito igual ao do script.
 includeRuntimeClasspath | Configuração avançada: Se true adiciona o classpath de tempo de execução da aplicação ao classpath de construção. | Não. Por defeito @true@.
{table}

A tarefa também suporta os seguintes elementos aninhados, todos eles estruturas de caminho Ant padrão:

* @classpath@ - O classpath de construção(utilizado para caregar os scripts Gant e Grails).
* @compileClasspath@ - Classpath utilizado para compilar as classes da aplicação.
* @runtimeClasspath@ - Classpath utilizado para correr a aplicação e empacotar o WAR. Tipicamente inclui tudo em @compileClasspath.
* @testClasspath@ - Classpath utilizado para compilar e correr os testes. Tipicamente inclui tudo em  @runtimeClasspath@.

A forma de popular estes caminhos cabe a cada um. Se utiliza o atributo @home@ e coloca as suas próprias dependências na directoria @lib@, então nem precisa utilizar nenhum deles. Para um exemplo da sua utilização, veja o ficheiro de construção Ant gerado para novas aplicações.

h3. Integração Maven

Grails fornece integração com "Maven 2":http://maven.apache.org através de um plugin Maven. O plugin Maven atual é baseado (mas acrescenta) na versãocriada por [Octo|http://forge.octo.com/], que fez um excelente trabalho com o original.

h4. Preparação

Para poder utilizar o novo plugin, tudo o que necessita é ter Maven 2 instalado e configurado. Isto porque *já não necessita instalar Grails separadamente para utilizá-lo com Maven!*

{note}
A integração Maven 2 para Grails foi desenhada e testada para Maven 2.0.9 e mais recentes. Não irá funcionar em versões mais antigas.
{note}

{note}
A configuração mvn por defeito NÃO fornece memória suficiente para correr o ambiente Grails. Recomendamos que adicione a seguinte configuração de variável de ambiente para evitar um mau desempenho:

@export MAVEN_OPTS="-Xmx512m -XX:MaxPermSize=256"@
{note}

h4. Criando um Projeto Maven Grails

Para criar um projeto Grails Mavenizedo basta executar o comando seguinte:

{code}
mvn archetype:generate -DarchetypeGroupId=org.grails \\\
    -DarchetypeArtifactId=grails-maven-archetype \\\
    -DarchetypeVersion=1.3.2 \\\
    -DgroupId=example -DartifactId=my-app
{code}

Escolha uma qualquer versão de grails, ID de grupo e ID de artefato que deseje para a sua aplicação, mas tudo o resto deve ficar como está escrito. Isto irá criar um novo projeto Maven com um POM e alguns outros ficheiros. Aquilo que não verá é algo que se assemelhe a uma aplicação Grails. Por isso, o próximo passo é criar a estrutura de projeto a que está habituado.
Mas primeiro, há que configurar o JDK alvo para Java 6, vamos fazê-lo agora. Abra my-app/pom.xml e mude
{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.5</source>
    <target>1.5</target>
  </configuration>
</plugin>
{code}
para
{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.6</source>
    <target>1.6</target>
  </configuration>
</plugin>
{code}

Então estará pronto para criar a estrutura do projeto:

{code}
cd my-app
mvn initialize
{code}

{note}
se vir uma mensagem semelhante a esta:

{code}
Resolving plugin JAR dependencies ...
:: problems summary ::
:::: WARNINGS
        module not found: org.hibernate#hibernate-core;3.3.1.GA
{code}

necessita adicionar os plugins manualmente a application.properties:

{code}
plugins.hibernate=2.0.0
plugins.tomcat=2.0.0
{code}

então execute

{code}
mvn compile
{code}

e os plugins hibernate e tomcat serão instalados.
{note}

Agora já tem uma aplicação Grails pronta a executar. O plugin integra-se no ciclo de construção standard, por isso pode utilizar as fases standard de Maven para construir e empacotar a sua aplicação:  @mvn clean@ ,  @mvn compile@ ,  @mvn test@ ,  @mvn package@ , @mvn install@ .

Também pode utiizar alguns dos comandos Grails que foram embrulhados como metas Maven:

* @grails:create-controller@ - Chama o comando [create-controller|commandLine]
* @grails:create-domain-class@ - Chama o comando [create-domain-class|commandLine]
* @grails:create-integration-test@ - Chama o comando [create-integration-test|commandLine]
* @grails:create-pom@ - Cria um novo POM Maven para um projeto Grails existente
* @grails:create-script@ - Chama o comando [create-script|commandLine]
* @grails:create-service@ - Chama o comando [create-service|commandLine]
* @grails:create-taglib@ - Chama o comando [create-tag-lib|commandLine]
* @grails:create-unit-test@ - Chama o comando [create-unit-test|commandLine]
* @grails:exec@ - Executa um script de linha de comando Grails arbitrário
* @grails:generate-all@ - Chama o comando [generate-all|commandLine]
* @grails:generate-controller@  - Chama o comando [generate-controller|commandLine]
* @grails:generate-views@ - Chama o comando [generate-views|commandLine]
* @grails:install-plugin@ - Chama o comando [install-plugin|commandLine]
* @grails:install-templates@ - Chama o comando [install-templates|commandLine]
* @grails:list-plugins@ - Chama o comando [list-plugins|commandLine]
* @grails:package@ - Chama o comando [package|commandLine]
* @grails:run-app@ - Chama o comando [run-app|commandLine]
* @grails:uninstall-plugin@ - Chama o comando [uninstall-plugin|commandLine]

Para uma lista, completa e atualizada, execute @mvn grails:help@

h4. Mavenizando um projeto existente

Criar um novo projeto é uma ótima maneira de começar, mas e se já tiver um projeto? Não vai querer criar um novo projeto e depois copiar o conteúdo do antigo para o recém criado. A solução é criar um POM para o projeto existente utilizando este comando Maven (substitua o número da versãopelo da versão de grails do seu projeto existente):
{code}
mvn org.grails:grails-maven-plugin:1.3.2:create-pom -DgroupId=com.mycompany
{code}
Quando este comando terminar, pode começar a utilizar as fases standard imediatamente, tais como @mvn package@. Note que deve especificar um ID de grupo quando criar o POM.

Também pode desejar definir o JDK alvo para Java 6; ver acima.

h4. Adicionando comandos Grails às fases

O POM standard criado para si por Grails já anexa os comandos principais de Grails apropriados às suas fases de construção correspondentes, assim sendo "compile" está na fase "compile" e "war" está na fase "package". No entanto isto não ajuda quando quer juntar o comando de um plugin a uma fase em particular. O exemplo clássico é o dos testes funcionais. Como garantir que os seus testes funcionais (usando um qualquer plugin pelo qual se tenha decidido) correm durante a fase "integration-test"?

Não tenha receio: tudo é possível. Neste caso, pode associar o comando a uma fase utilizando um bloco de "execução" extra:
{code:xml}
<plugin>
    <groupId>org.grails</groupId>
    <artifactId>grails-maven-plugin</artifactId>
    <version>1.3.2</version>
    <extensions>true</extensions>
    <executions>
        <execution>
            <goals>
            ...
            </goals>
        </execution>
        <!-- Add the "functional-tests" command to the "integration-test" phase -->
        <execution>
            <id>functional-tests</id>
            <phase>integration-test</phase>
            <goals>
                <goal>exec</goal>
            </goals>
            <configuration>
                <command>functional-tests</command>
            </configuration>
        </execution>
    </executions>
</plugin>
{code}

Isto também demonstra a meta @grails:exec@, que pode ser utilizado para executar qualquer comando Grails. Passe simplesmente o nome do comando como a propriedade de sistema @command@, e opcionalmente especifique os argumentos com a propriedade @args@:
{code}
mvn grails:exec -Dcommand=create-webtest -Dargs=Book
{code}

h4. Debugging de um Projeto Maven Grails

Maven pode ser lançado em modo debug utilizando o comando "mvnDebug". Para lançar a sua aplicação Grails em debug, execute simplesmente:

{code}
mvnDebug grails:run-app
{code}

O processo será suspenso no começo e ficará a escutar um debugger no port0 8000.

Se necessita de mais controlo sobre o debugger, isso pode ser especificado utilizando a variável de ambiente MAVEN_OPTS, e lançando Maven com o comando por defeito "mvn":

{code}
MAVEN_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"
mvn grails:run-app
{code}

h4. Levantando questões

Se encontar algum problema durante a integração Maven, por favor levante uma questão JIRA como uma sub-tarefa de [GRAILS-3547|http://jira.codehaus.org/browse/GRAILS-3547].
