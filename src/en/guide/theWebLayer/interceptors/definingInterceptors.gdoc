By default interceptors will match the controller name they apply to be convention. For example if you have an interceptor called @BookInterceptor@ then all requests the actions of the @BookController@ will trigger the interceptor.

An @Interceptor@ implements the [Interceptor|api:grails.artefact.Interceptor] trait and provides 3 methods that can be used to intercept requests:

{code}
    /**
     * Executed before a matched action
     *
     * @return Whether the action should continue and execute
     */
    boolean before() { true }

    /**
     * Executed after the action executes but prior to view rendering
     *
     * @return True if view rendering should continue, false otherwise
     */
    boolean after() { true }

    /**
     * Executed after view rendering completes
     *
     * @param t The exception instance if an exception was thrown, null otherwise
     */
    void afterView(Throwable t) {}
{code}

As described above the @before@ method is executed prior to an action and can cancel the execution of the action by returning @false.

The @after@ method is executed after an action executes and can halt view rendering if it returns false. The @after@ method can also modify the view or model using the @view@ and @model@ properties:

{code}
boolean after() {
  model.foo = "bar" // add a new model attribute called 'foo'
  view = 'alternate' // render a different view called 'alternate'
  true
}
{code}

The @afterView@ method is executed after view rendering completes and if an exception occurs will receive the exception as the first argument to the method.
